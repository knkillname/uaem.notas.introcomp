# PrÃ¡ctica 7: El Poder de los MontÃ­culos (Heaps) ğŸ—ï¸

> "El orden en el caos es la primera necesidad de la supervivencia."

En el Cuaderno 10, exploramos algoritmos voraces y dinÃ¡micos. Sin embargo, hay una estructura de datos que es fundamental para muchos algoritmos eficientes (como el de Dijkstra para mapas o la codificaciÃ³n de Huffman para compresiÃ³n): el **MontÃ­culo** o **Heap**.

Originalmente parte del cuaderno de teorÃ­a, hemos movido este tema aquÃ­ para darle el espacio que se merece y ponerlo a prueba con un escenario de vida o muerte. ğŸ§Ÿâ€â™‚ï¸

## 1. TeorÃ­a: Â¿QuÃ© es un MontÃ­culo?

Un **montÃ­culo** (o *heap* en inglÃ©s) es una estructura de datos especializada en organizar informaciÃ³n para acceder rÃ¡pidamente al elemento "mÃ¡s importante" (el mÃ­nimo o el mÃ¡ximo).

Imagina que el montÃ­culo es como un Ã¡rbol genealÃ³gico ğŸŒ³ (especÃ­ficamente, un **Ã¡rbol binario**, donde cada "padre" tiene como mÃ¡ximo dos "hijos"). Pero, Â¡aquÃ­ viene lo genial! Aunque pensemos en Ã©l como un Ã¡rbol, en Python (con el mÃ³dulo `heapq`) lo guardamos de forma muy astuta usando una simple **lista**.

### La Propiedad del MontÃ­culo ğŸ”‘

En un **montÃ­culo mÃ­nimo** (min-heap), que es el estÃ¡ndar en Python:

- Cualquier "hijo" siempre es **mayor o igual** que su "padre".
- **Consecuencia**: Â¡El elemento mÃ¡s pequeÃ±o siempre estÃ¡ en la raÃ­z (Ã­ndice 0)! ğŸ¥‡

### El Truco de la Lista: Ãrboles en Arrays ğŸ§ 

Â¿CÃ³mo guardamos un Ã¡rbol en una lista plana? Usamos matemÃ¡ticas simples para navegar entre padres e hijos basÃ¡ndonos en sus Ã­ndices (posiciones).

Si un elemento estÃ¡ en el Ã­ndice `i`:

- Su **Hijo Izquierdo** estÃ¡ en: `2 * i + 1`
- Su **Hijo Derecho** estÃ¡ en: `2 * i + 2`
- Su **Padre** estÃ¡ en: `(i - 1) // 2` (divisiÃ³n entera)

**Ejemplo Visual:**
Imagina este Ã¡rbol:

```text
      1  (Ã­ndice 0)
    /   \
   5     3  (Ã­ndices 1 y 2)
  / \
 9   7      (Ã­ndices 3 y 4)
```

En una lista de Python se ve asÃ­: `[1, 5, 3, 9, 7]`

- Â¿QuiÃ©n es el padre del `9` (Ã­ndice 3)?
  - FÃ³rmula: `(3 - 1) // 2` = `2 // 2` = `1`.
  - En el Ã­ndice `1` estÃ¡ el `5`. Â¡Correcto! âœ…

### Operaciones MÃ¡gicas: Â¿CÃ³mo funciona por dentro? ğŸª„

Para entender la complejidad, necesitamos ver quÃ© pasa bajo el capÃ³.

#### 1. `heappush` y el Arte de "Flotar" (Bubble Up) ğŸˆ

Imagina que aÃ±ades un nuevo paciente.

1. **Al final de la fila**: Primero, lo colocamos al final de la lista (el Ãºltimo nodo del Ã¡rbol).
2. **Â¿Es mÃ¡s importante que su jefe?**: Comparamos al nuevo con su "padre".
3. **Intercambio**: Si el nuevo es menor (mÃ¡s prioritario en un min-heap) que su padre, Â¡cambian de lugar!
4. **Repetir**: Esto sigue pasando hasta que el nuevo encuentra un padre que sea menor que Ã©l, o llega a la cima (raÃ­z).

**Costo**: En el peor caso, recorre la altura del Ã¡rbol. Como es un Ã¡rbol binario, la altura es $\log_2 n$.
**Complejidad**: $O(\log n)$.

#### 2. `heappop` y la TÃ©cnica de "Hundir" (Bubble Down) âš“

Cuando sacamos al paciente de la raÃ­z (el mÃ¡s prioritario):

1. **Hueco en la cima**: Sacamos la raÃ­z. Queda un hueco.
2. **El Ãºltimo serÃ¡ el primero**: Movemos el *Ãºltimo* elemento de la lista a la raÃ­z para tapar el hueco.
3. **Â¿Pesa mucho?**: Probablemente este elemento no deba estar ahÃ­. Lo comparamos con sus hijos.
4. **Intercambio con el menor**: Si es mayor que alguno de sus hijos, lo intercambiamos con el hijo *mÃ¡s pequeÃ±o*.
5. **Repetir**: Sigue bajando hasta que sea menor que sus hijos o se convierta en una hoja.

**Costo**: TambiÃ©n recorre la altura del Ã¡rbol.
**Complejidad**: $O(\log n)$.

#### 3. `heapify` (Convertir)

Convierte una lista desordenada en un montÃ­culo. Aunque parezca que harÃ­a $n$ inserciones ($O(n \log n)$), usa un truco matemÃ¡tico (empezar a hundir desde la mitad hacia atrÃ¡s) que lo hace en **tiempo lineal**.
**Complejidad**: $O(n)$.

---

## 2. Parte 1: Construyendo el Motor (ImplementaciÃ³n Manual) ğŸ› ï¸

Antes de usar la librerÃ­a mÃ¡gica de Python (`heapq`), Â¡vamos a construir nuestro propio montÃ­culo desde cero! Esto te ayudarÃ¡ a entender realmente cÃ³mo funciona.

### Paso 1: NavegaciÃ³n en el Ãrbol

Implementa funciones auxiliares para moverte por los Ã­ndices de la lista.

```python
def padre(i):
    return (i - 1) // 2

def hijo_izq(i):
    return 2 * i + 1

def hijo_der(i):
    return 2 * i + 2
```

### Paso 2: Flotar (Bubble Up) ğŸˆ

Crea una funciÃ³n `flotar(lista, i)` que tome un elemento en el Ã­ndice `i` y lo suba hasta su posiciÃ³n correcta si es menor que su padre.

```python
def flotar(heap, i):
    # Mientras no sea la raÃ­z y sea menor que su padre...
    while i > 0 and heap[i] < heap[padre(i)]:
        # Â¡Intercambiar con el padre!
        # ... tu cÃ³digo aquÃ­ ...
        # Actualizar i al nuevo Ã­ndice (el del padre)
        i = padre(i)
```

### Paso 3: Hundir (Bubble Down) âš“

Crea una funciÃ³n `hundir(lista, i)` que tome un elemento en el Ã­ndice `i` y lo baje si es mayor que alguno de sus hijos.

```python
def hundir(heap, i):
    n = len(heap)
    while True:
        menor = i
        izq = hijo_izq(i)
        der = hijo_der(i)
        
        # Â¿El hijo izquierdo existe y es menor que el actual menor?
        if izq < n and heap[izq] < heap[menor]:
            menor = izq
            
        # Â¿El hijo derecho existe y es menor que el actual menor?
        if der < n and heap[der] < heap[menor]:
            menor = der
            
        # Si el menor sigue siendo i, Â¡ya terminamos!
        if menor == i:
            break
            
        # Si no, intercambiamos y seguimos hundiendo
        heap[i], heap[menor] = heap[menor], heap[i]
        i = menor
```

### Paso 4: Las Operaciones Maestras

Ahora usa tus funciones `flotar` y `hundir` para implementar:

1. `insertar(heap, valor)`: AÃ±ade al final (`append`) y luego `flotar`.
2. `extraer_minimo(heap)`: Guarda la raÃ­z, mueve el Ãºltimo al principio, haz `pop` al Ãºltimo, y luego `hundir` la nueva raÃ­z.

---

## 3. Parte 2: El DesafÃ­o Zombie (Usando `heapq`) ğŸ§Ÿâ€â™€ï¸ğŸ¥

Ahora que ya sabes cÃ³mo funciona el motor, Â¡usemos la versiÃ³n turbo de Python!

Estamos en el aÃ±o 2045. Un virus zombie se ha propagado. TÃº eres el ingeniero de software principal del Ãºltimo refugio de la humanidad. Tu tarea es programar el sistema de **Triaje Automatizado** para la enfermerÃ­a.

### Tu MisiÃ³n

Implementa un sistema de **Cola de Prioridad** usando `heapq` para gestionar la atenciÃ³n de pacientes.

#### Requerimientos

1. **Clase `Paciente`**:
    - Debe tener `nombre` (str) y `nivel_infeccion` (int).
    - El `nivel_infeccion` va de 1 (rasguÃ±o) a 100 (transformaciÃ³n inminente).
    - **Truco**: `heapq` en Python es un *min-heap* (saca el nÃºmero mÃ¡s pequeÃ±o primero). Pero tÃº quieres atender al de *mayor* infecciÃ³n primero.
        - *OpciÃ³n A*: Guardar la infecciÃ³n como nÃºmero negativo (ej: -90 es menor que -10, asÃ­ que saldrÃ¡ antes).
        - *OpciÃ³n B*: Implementar los mÃ©todos mÃ¡gicos de comparaciÃ³n (`__lt__`) en la clase para invertir la lÃ³gica.

2. **Sistema de Triaje**:
    - Crea una lista vacÃ­a que serÃ¡ tu montÃ­culo.
    - Simula la llegada de 5 pacientes con diferentes niveles de infecciÃ³n (Â¡desordenados!).
    - Muestra quiÃ©n es el siguiente en ser atendido sin sacarlo de la cola (mirar el tope).
    - Atiende (extrae) a los pacientes uno por uno. DeberÃ­an salir del mÃ¡s grave al menos grave.

### CÃ³digo Base para Empezar

```python
import heapq

class Paciente:
    def __init__(self, nombre, nivel_infeccion):
        self.nombre = nombre
        self.nivel_infeccion = nivel_infeccion

    # Implementa __lt__ (less than) para que heapq sepa cÃ³mo ordenarlos.
    # Recuerda: queremos que SALGA PRIMERO el de MAYOR infecciÃ³n.
    # En un min-heap, sale primero el "menor".
    # AsÃ­ que definimos que un Paciente A es "menor" que B si su infecciÃ³n es MAYOR.
    def __lt__(self, otro):
        return self.nivel_infeccion > otro.nivel_infeccion

    def __repr__(self):
        return f"Paciente({self.nombre}, InfecciÃ³n: {self.nivel_infeccion}%)"

# Tu simulaciÃ³n aquÃ­...
sala_de_espera = []
```

### Interludio MatemÃ¡tico: Â¿Por quÃ© Logaritmos? ğŸ“‰

Decimos que las operaciones cuestan $O(\log n)$ porque recorren la altura del Ã¡rbol. Pero, Â¿quÃ© relaciÃ³n hay entre la altura y el nÃºmero de elementos?

**Ejercicio Mental:**
Imagina un Ã¡rbol binario perfecto (lleno por completo).

- **Nivel 0 (RaÃ­z)**: 1 nodo ($2^0$)
- **Nivel 1**: 2 nodos ($2^1$)
- **Nivel 2**: 4 nodos ($2^2$)
- **Nivel 3**: 8 nodos ($2^3$)

1. Completa la secuencia hasta el nivel 10.
2. Si sumas todos los nodos hasta el nivel 3, tienes $1+2+4+8 = 15$ nodos. La altura es 3.
3. Observa que $2^{3+1} - 1 = 16 - 1 = 15$. Â¡AjÃ¡!
4. La fÃ³rmula aproximada es $n \approx 2^h$ (donde $n$ es el nÃºmero de nodos y $h$ la altura).

Si despejamos la altura $h$:
$$ h \approx \log_2 n $$

Esto significa que cada vez que **duplicamos** la cantidad de datos ($n$), la altura del Ã¡rbol ($h$) solo crece en **1**.

- 1,000 datos $\rightarrow$ altura ~10
- 2,000 datos $\rightarrow$ altura ~11
- 1,000,000 datos $\rightarrow$ altura ~20

Â¡Por eso es tan rÃ¡pido! Solo recorres 20 pasos para organizar un millÃ³n de elementos.

### GuÃ­a de AnÃ¡lisis de Complejidad ğŸ§ 

Para responder por quÃ© usamos un Heap, completa esta tabla comparativa en tu mente (o papel):

| OperaciÃ³n | Lista Ordenada (mantenerla ordenada) | MontÃ­culo (Heap) |
| :--- | :--- | :--- |
| **Insertar un paciente** | Tienes que buscar posiciÃ³n y *mover* todos los elementos siguientes. **$O(n)$** | Solo "flotas" por la altura del Ã¡rbol. **$O(\log n)$** |
| **Atender al siguiente (Extraer)** | Sacas el primero y mueves el resto. **$O(n)$** (o $O(1)$ si es eficiente) | Sacas la raÃ­z y "hundes" el reemplazo. **$O(\log n)$** |

1. Si tienes 1,000,000 de pacientes, $\log_2(1,000,000) \approx 20$.
    - Insertar en lista: ~1,000,000 operaciones.
    - Insertar en Heap: ~20 operaciones.
    - **Â¿Ves la diferencia?** Explica con tus palabras por quÃ© el Heap es ideal para una sala de urgencias muy concurrida.

2. **Justicia**: Si dos pacientes tienen el mismo nivel de infecciÃ³n, Â¿cuÃ¡l sale primero con tu implementaciÃ³n? Â¿Es estable el algoritmo?
3. **Herramientas Extra**: Investiga `heapq.nlargest`. Â¿SerÃ­a mÃ¡s eficiente usar eso si solo quieres ver a los 3 mÃ¡s graves, en lugar de extraer a todos?

---

## 3. Reto Extra: El BÃºnker VIP ğŸ’

El refugio tiene un sistema de "CrÃ©ditos Sociales". Si dos personas tienen la misma gravedad de herida, se atiende primero a la que tenga mÃ¡s crÃ©ditos (VIP).

Modifica tu clase `Paciente` para manejar este desempate.
